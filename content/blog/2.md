---
title: "[yap transcript] On first principles thinking"
date: "10 Dec, 2024"
---

# First Principles Thinking and Critical Thinking in System Design

## Disclaimer
This is a transcript from a 15-minute recording that was supposed to be about critical thinking but immediately devolved into first principles thinking. It stems from a (very funny) screenshot sent to me in DMs on **2024-11-09 23**.

1. **Critical thinking** is a completely different thing. In the case of the example I used during the yap, it would be more akin to asking yourself, "What are the different ways I could implement the hit detection in this game?" and the process of uncovering and then fleshing these out.

2. This is very unpolished. I just cleaned up the "right?", "ums", and endless repetitions. It's missing a lot of juicy details, like how under/over decomposition can be avoided, the kind of "pitstop" questions you can ask yourself, such as "Is this component's interface clear (e.g., clear inputs/outputs)? Can it be implemented independently of other components?" etc.

Please take this for what it is: a transcript of a random 15-minute rant full of "ummms" and wandering, which I used to respond to a DM.

---

## Critical Thinking in System Design and Coding
Critical thinking is pretty important when it comes to designing and building systems, but also in the day-to-day of writing code. Here are some of the things that you want to do.

**Side-note:** To improve critical thinking, you also kind of want to be thinking about thinking. For that, I recommend Dan B's website. He's a good buddy of mine. It's a good website. Maybe just read that instead.

---

## First Principles Thinking
Let's start by talking about **first principles thinking**. You want to break down big problems and systems (I use systems and problems interchangeably throughout) into smaller, simpler parts — the basic, primitive components that compose the problems or systems in question.

For example, if you're trying to build a Tetris clone, you don't want to think about the whole thing at once. You can’t start that way; it’s too big and complex. Instead, you want to think about each of the things that compose a Tetris clone, such as:

- How are you going to represent the Tetris blocks?
- How are you going to handle them colliding with each other?
- How are you going to draw them on the screen? (Even that is a big problem, which you can break down into many other smaller problems.)
- How is the score going to work?
- How are you going to handle controls? For example, how am I going to listen to keyboard inputs and apply logic to move the pieces? If they press R, how am I going to rotate the shape 90 degrees?

So, you want to break these down into smaller problems, right? And then you want to keep breaking them down until you get two things:

1. **Something that feels actionable.**
2. **Something that's somewhat irreducible** — something that can’t really be broken down into anything simpler.

You don't have to be absurd with it. You don't have to keep breaking things down into the absolute smallest components you can, otherwise you never get anywhere. But yeah, that's the first step: the decomposition of the problem into the smaller components that compose it.

---

## Identifying Atomic Truths
What you're trying to figure out is the **atomic things** that are inherent to what you're trying to do — the things that are not going to go away, no matter the approach. For example, if you're trying to build a Tetris clone, some of the atomic truths are:

- You're going to need the blocks.
- They need to appear from the top of the screen.
- You might need to preview the next five blocks that are going to appear (because Tetris usually does that).
- You need to be able to rotate them.
- They need to collide.
- When they make a line, they need to disappear.

These are the things that are absolutely inherent to Tetris. They can be broken down, but they're not ever going to disappear. So, once you've established these truths, you want to try to formalize and clarify them to some extent.

---

## Formalizing and Clarifying Components
This is kind of implicit in the decomposition process, but sometimes you can spend a bit more time formalizing and making sure that the components are clear and have clear requirements or definitions. Part of this process is not just the practical act of decomposing the problem and establishing the definitions; it's also about spending time in the domain so that you're familiar with the fundamentals of what you're trying to achieve.

The more time you spend thinking about it, the bigger your capacity to be intuitive and apply critical thinking will be.

---

## Building Solutions from Components
From these components that you've broken the bigger problem into, you can start building solutions with them. For example, you can literally get a whiteboard or open [Google Draw](http://draw.google.com), put these components (or even smaller problems) in little rectangles, and start composing relationships between them. You can also bunch up several of these components into a bigger rectangle. For example, 4-5 things might actually compose "hit detection."

---

## Avoiding Assumptions and Conventional Wisdom
You also want to systematically avoid assumptions and conventional wisdom. You do this by focusing on the core of what you are trying to achieve, always going at it from first principles (using the technique we’ve been discussing). This is something that's a little harder at first, but you want to avoid, even remove assumptions. You want to avoid falling into paths of thinking that feel natural but are not necessary.

This part really comes from decomposing the problem or the system into its fundamental blocks and understanding what you're trying to do. Letting yourself find your **own path** to build it — because if you’ve broken down the problem well enough, your intuition will end up being very close to conventional wisdom (or better).

---

## Setting the Negative Space of the Problem
A thing you can always do (and most of the time, should) is set the **negative space** of the problem: set a boundary around the problem — everything that's not in the problem space is something you don't have to do. In the Tetris example, the negative space is quite large if you’re doing a basic Tetris clone. It also depends on what platform you want the game to be playable on, but for example, if you’re using a 2D game engine for JS, the rendering, etc., is not part of your problem space. This is solved for you.

So, you obviously don't want to list them all out, but there are things that could be in your Tetris clone that won't be, and they are important to list out because it narrows the problem space.

---

## Summary
So yeah, you list down all these components that you've broken down from the main problem/system, you try to identify some relationships between them and group them, you ask a lot of “why’s” at every decision you take, so that you can figure out what is really necessary. And then, you now have at least a list of actionable items. You have things you can build because they are now much simpler. You can attack them one by one. You have a sense of the problem as a whole. Each of the smaller components, you can attempt to build differently, but at the end of the day, you **KNOW** you need that component for the problem to be solved / the system to exist.
